<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2018%2F06%2F24%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之单例模式 在某些应用场景下，一个类只能有一个实例，如Android系统中的一些系统服务，SurfaceFlinger等，都是被设计成单例模式，单例模式可以分为两种，懒汉模式和饿汉模式，介绍如下. 懒汉模式 所谓的懒汉模式就是如果不调用getInstance()方法，类的唯一实例是不存在的，只有调用的时候才会生成这个实例； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Singleton &#123; public: static Singleton* getInstance(); private: Singleton() &#123;&#125; ~Singleton() &#123;&#125; static Singleton *m_pInstance;//类的唯一实例. &#125;; Singleton* Singleton::m_pInstance = nullptr; //静态成员，类体外初始化. Singleton* Singleton::getInstance() //第一次调用该函数的时候才会创建该类的唯一实例，所以是“懒汉模式”. &#123; if (nullptr == m_pInstance ) &#123; m_pInstance = new Singleton(); &#125; return m_pInstance; &#125; 饿汉模式 s所谓的饿汉模式就是不管调不调用getInstance()方法，类的唯一实例都是创建好的，调用的时候会将该实例作为返回值返回; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Singleton &#123; public: static const Singleton* getInstance(); private: Singleton() &#123;&#125; ~Singleton() &#123;&#125; static const Singleton *m_pInstance;//类的静态常量 &#125;; const Singleton* Singleton::m_pInstance = new Singleton();//体外初始化. const Singleton* Singleton::getInstance() &#123; return m_pInstance; &#125; 注意这里面需要注意两点： 1. m_pInstance是类的静态常量，是非整型或枚举类型的，因此只能在类体外进行初始化; 2. 类的静态常量初始化是在主线程中，调用main()函数之前完成，因此是线程安全的. 线程安全 懒汉模式可能存在着线程安全问题： 1 2 3 4 5 6 7 8 Singleton* Singleton::getInstance() &#123; if (nullptr == m_pInstance ) &#123; m_pInstance = new Singleton(); &#125; return m_pInstance; &#125; 这段代码是非线程安全的，假设A线程进入if (...) 还没有new Singleton就被B线程抢占，B线程同样会进入if(...)判断。这样，这两个线程都会去new一个Singleton()实例，出现多线程访问问题。 加锁 解决上述问题的办法之一是加锁. 1 2 3 4 5 6 7 8 9 10 Singleton* Singleton::getInstance() &#123; mutex.lock(); if (nullptr == m_pInstance ) &#123; m_pInstance = new Singleton(); &#125; mutex.unlock(); return m_pInstance; &#125; 双检锁 上面的代码在nullptr != m_pInstance时会出现无意义的加锁，解锁动作，因此可以改进如下，双重check： 1 2 3 4 5 6 7 8 9 10 11 12 13 Singleton* Singleton::getInstance() &#123; if (nullptr == m_pInstance ) //防止无意义地加锁，解锁 &#123; mutex.lock(); if (nullptr == m_pInstance ) //里面的判断不能少，因为外层一个if(..)是非线程安全的. &#123; m_pInstance = new Singleton(); &#125; mutex.unlock(); &#125; return m_pInstance; &#125; 实例初始化 实际上还可以进行改进，就是在创建类的唯一实例时，类可能还没有初始化完成，只是分配了内存并将内存地址赋值给m_pInstance了。此时其它线程使用m_pInstance就会有问题，修改如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Singleton* Singleton::getInstance() &#123; if (nullptr == m_pInstance ) //防止无意义地加锁，解锁 &#123; mutex.lock(); if (nullptr == m_pInstance ) //里面的判断不能少，因为外层一个if(..)是非线程安全的. &#123; Singleton *temp = new Singleton();//没有初始化完成之前不要使用m_pInstance访问内存. m_pInstance = temp; &#125; mutex.unlock(); &#125; return m_pInstance; &#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ mutable关键字]]></title>
    <url>%2F2018%2F06%2F20%2FC-mutable%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[引言：对于类的成员函数来说，如果它不修改类的状态，一般将其声明为const函数. 但是如果我们想在类的const成员函数中修改与类的状态无关的成员变量，那么该怎么做呢？答案是使用mutable关键字。 一、mutable关键字是为了突破const关键字的限制而引入的，修饰一个类的成员变量，表示这个成员变量在const函数中也是可以被修改的。 mutable关键字只能修饰类的非静态和非常量的成员变量，即不能与static和const连用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Info &#123; public: Info() : mValue(0) &#123; &#125; inline void Output() const //并不会修改类的状态，但会修改与状态无关的成员. &#123; mValue++; cout &lt;&lt; "Output the object: " &lt;&lt; this &lt;&lt; endl; &#125; inline void GetOutputTimes() const &#123; return mValue; &#125; private: mutable int mValue;//表示类对象输出的次数. &#125;; //Test case. &#123; Info* pObj = new Info(); pObj-&gt;Output(); pObj-&gt;Output(); cout &lt;&lt; pObj-&gt;GetOutputTimes() &lt;&lt; endl;//输出2. &#125; 在以上代码段中，const类型的成员函数Output()会修改成员变量mValue。如果不将mValue声明为mutable类型是不行的。 二、即使类/结构体对象是const的，但是仍然可以修改它的mutable成员. 1 2 3 4 5 6 7 8 9 10 11 12 13 struct Data &#123; int a; mutable int b;//can modify anytime. &#125;; //Test mutable &#123; const Data *data = new Data&#123; 1, 2 &#125;; data-&gt;b = 3; cout &lt;&lt; "a = " &lt;&lt; data-&gt;a &lt;&lt; ", b = " &lt;&lt; data-&gt;b &lt;&lt; endl; &#125; volatile关键字 用volatile关键字修饰变量，实际上是告诉编译器，CPU每次使用该变量的时候可以直接从内存中读取，而不是在寄存器中读取。 volatile关键字保证了变量在寄存器中被修改了以后会及时地刷新到内存中，保持了寄存器和memory的一致性。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ using关键字总结]]></title>
    <url>%2F2018%2F06%2F20%2FC-using%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[使用场景一：使用using关键字重新定义访问权限 我们知道： - 当采用private/protected继承时，父类中的public和protected成员在子类中都是private/protected的.这些从父类继承过来的成员，子类虽然可见， 但是子类的实例是不可以直接访问这些private/protected成员的. - 不管采用什么方式的继承修饰符，父类的private成员对子类都是不可见的; 如果想让子类的实例访问从父类继承过来的private/protected成员，该怎么办呢？有两种方式可以解决： 第一种方式： 在子类中定义一个public方法，对父类继承过来的private/protected成员进行wrap，这样就可以通过子类的实例间接访问到这些private/protected成员. 示例如下: double student::sum() const //public student method. { return valarray&lt;double&gt;::sum(); //use privately-inherited method. } 第二种方式： 在子类的public部分使用using关键字声明，即重新定义这些privately-inherited方法/成员的访问权限. class student : private std::valarray&lt;double&gt; { ...// public: using std::valarray&lt;double&gt;::min; using std::valarray&lt;double&gt;::max; ...// }; 这样声明了以后就可以让student类的实例访问private继承过来的valarray::min和valarray::max了. 一个完整的例子如下： //=========================================================== //CBase class CBase { public: CBase(int data) : mData(data) {} ~CBase() {} string toString() const; private: int mData; }; string CBase::toString() const { stringstream ss; ss &lt;&lt; mData; string temp = &quot;Data: &quot; + ss.str(); return temp; } //============================================================ //CDerived class CDerived : private CBase { public: CDerived(int data = 2) : CBase(data) {} ~CDerived() {} using CBase::toString; private: ...// }; 在子类的public部分使用using CBase::toString声明以后，子类的实例就可以访问toString()方法了: CDerived* pDerived = new CDerived(); cout &lt;&lt; pDerived-&gt;toString() &lt;&lt; endl; 注意事项： 1. 只有子类可见的父类成员才能using,即父类中的public/protected成员才可以，父类的private成员不行. 2. 使用using关键字修改函数的访问权限时，不用加方法的参数和返回值，不管该方法在父类中重载了多少个版本，只要函数名就可以了. 如using CBase::toString; 使用场景二：using关键字可以用于声明模板类型 我们知道，typedef可以用于声明类型的别名，示例如下： typedef unsigned int size_t;//定义size_t为unsigned int类型. 但是typedef却不能够声明模板类型，而using关键字可以很方便地声明模板类型，示例如下： template&lt;typename T&gt; using vecType = vector&lt;T&gt;;//声明 vecType&lt;int&gt; Data;//使用，此时vecType&lt;&gt;就是类的模板，和vector&lt;&gt;是一样的. Data.push_back(1); Data.push_back(2); 在STL源码中有大量的这种使用方式，示例如下： // ALIAS TEMPLATE _Iter_value_t template&lt;class _Iter&gt; using _Iter_value_t = typename iterator_traits&lt;_Iter&gt;::value_type; // ALIAS TEMPLATE _Iter_diff_t template&lt;class _Iter&gt; using _Iter_diff_t = typename iterator_traits&lt;_Iter&gt;::difference_type; // ALIAS TEMPLATE _Iter_cat_t template&lt;class _Iter&gt; using _Iter_cat_t = typename iterator_traits&lt;_Iter&gt;::iterator_category;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
