<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++ mutable关键字]]></title>
    <url>%2F2018%2F06%2F20%2FC-mutable%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[引言：对于类的成员函数来说，如果它不修改类的状态，一般将其声明为const函数. 但是如果我们想在类的const成员函数中修改与类的状态无关的成员变量，那么该怎么做呢？答案是使用mutable关键字。 一、mutable关键字是为了突破const关键字的限制而引入的，修饰一个类的成员变量，表示这个成员变量在const函数中也是可以被修改的。 mutable关键字只能修饰类的非静态和非常量的成员变量，即不能与static和const连用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Info &#123; public: Info() : mValue(0) &#123; &#125; inline void Output() const //并不会修改类的状态，但会修改与状态无关的成员. &#123; mValue++; cout &lt;&lt; "Output the object: " &lt;&lt; this &lt;&lt; endl; &#125; inline void GetOutputTimes() const &#123; return mValue; &#125; private: mutable int mValue;//表示类对象输出的次数. &#125;; //Test case. &#123; Info* pObj = new Info(); pObj-&gt;Output(); pObj-&gt;Output(); cout &lt;&lt; pObj-&gt;GetOutputTimes() &lt;&lt; endl;//输出2. &#125; 在以上代码段中，const类型的成员函数Output()会修改成员变量mValue。如果不将mValue声明为mutable类型是不行的。 二、即使类/结构体对象是const的，但是仍然可以修改它的mutable成员. 1 2 3 4 5 6 7 8 9 10 11 12 13 struct Data &#123; int a; mutable int b;//can modify anytime. &#125;; //Test mutable &#123; const Data *data = new Data&#123; 1, 2 &#125;; data-&gt;b = 3; cout &lt;&lt; "a = " &lt;&lt; data-&gt;a &lt;&lt; ", b = " &lt;&lt; data-&gt;b &lt;&lt; endl; &#125; volatile关键字 用volatile关键字修饰变量，实际上是告诉编译器，CPU每次使用该变量的时候可以直接从内存中读取，而不是在寄存器中读取。 volatile关键字保证了变量在寄存器中被修改了以后会及时地刷新到内存中，保持了寄存器和memory的一致性。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ using关键字总结]]></title>
    <url>%2F2018%2F06%2F20%2FC-using%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[使用场景一：使用using关键字重新定义访问权限 我们知道： - 当采用private/protected继承时，父类中的public和protected成员在子类中都是private/protected的.这些从父类继承过来的成员，子类虽然可见， 但是子类的实例是不可以直接访问这些private/protected成员的. - 不管采用什么方式的继承修饰符，父类的private成员对子类都是不可见的; 如果想让子类的实例访问从父类继承过来的private/protected成员，该怎么办呢？有两种方式可以解决： 第一种方式： 在子类中定义一个public方法，对父类继承过来的private/protected成员进行wrap，这样就可以通过子类的实例间接访问到这些private/protected成员. 示例如下: double student::sum() const //public student method. { return valarray&lt;double&gt;::sum(); //use privately-inherited method. } 第二种方式： 在子类的public部分使用using关键字声明，即重新定义这些privately-inherited方法/成员的访问权限. class student : private std::valarray&lt;double&gt; { ...// public: using std::valarray&lt;double&gt;::min; using std::valarray&lt;double&gt;::max; ...// }; 这样声明了以后就可以让student类的实例访问private继承过来的valarray::min和valarray::max了. 一个完整的例子如下： //=========================================================== //CBase class CBase { public: CBase(int data) : mData(data) {} ~CBase() {} string toString() const; private: int mData; }; string CBase::toString() const { stringstream ss; ss &lt;&lt; mData; string temp = &quot;Data: &quot; + ss.str(); return temp; } //============================================================ //CDerived class CDerived : private CBase { public: CDerived(int data = 2) : CBase(data) {} ~CDerived() {} using CBase::toString; private: ...// }; 在子类的public部分使用using CBase::toString声明以后，子类的实例就可以访问toString()方法了: CDerived* pDerived = new CDerived(); cout &lt;&lt; pDerived-&gt;toString() &lt;&lt; endl; 注意事项： 1. 只有子类可见的父类成员才能using,即父类中的public/protected成员才可以，父类的private成员不行. 2. 使用using关键字修改函数的访问权限时，不用加方法的参数和返回值，不管该方法在父类中重载了多少个版本，只要函数名就可以了. 如using CBase::toString; 使用场景二：using关键字可以用于声明模板类型 我们知道，typedef可以用于声明类型的别名，示例如下： typedef unsigned int size_t;//定义size_t为unsigned int类型. 但是typedef却不能够声明模板类型，而using关键字可以很方便地声明模板类型，示例如下： template&lt;typename T&gt; using vecType = vector&lt;T&gt;;//声明 vecType&lt;int&gt; Data;//使用，此时vecType&lt;&gt;就是类的模板，和vector&lt;&gt;是一样的. Data.push_back(1); Data.push_back(2); 在STL源码中有大量的这种使用方式，示例如下： // ALIAS TEMPLATE _Iter_value_t template&lt;class _Iter&gt; using _Iter_value_t = typename iterator_traits&lt;_Iter&gt;::value_type; // ALIAS TEMPLATE _Iter_diff_t template&lt;class _Iter&gt; using _Iter_diff_t = typename iterator_traits&lt;_Iter&gt;::difference_type; // ALIAS TEMPLATE _Iter_cat_t template&lt;class _Iter&gt; using _Iter_cat_t = typename iterator_traits&lt;_Iter&gt;::iterator_category;]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
